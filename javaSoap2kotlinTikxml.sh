#!/usr/bin/perl
use v5.14;
use strict;
use Data::Dumper;
use File::Basename;
use File::Path qw/make_path/;
use File::Find;
use File::Spec;
no warnings 'experimental';

if (!defined @ARGV[0]) {
	print "please provide folder with java models generated by wsimport tool";
	exit -1;
}
{ #scope for not leaking global vars
my $path = File::Spec->canonpath(@ARGV[0]);
my $root = dirname($path);
my $dir = basename($path);
my $ktdir = File::Spec->catdir($root, $dir."_kt");

main(File::Spec->catdir($root, $dir), $ktdir);
print "\nclasses generated into $ktdir. Remember to add generated TypeAdapters for enums when creating TikXml instance with `addEnumAdapters\()` extension\n";
}
exit 0; #just an indicator that there is no global code after this point

my @additionalConverters = ();

# param in $dir - directory where are generated java classes. directory structure will be copied.
sub main
{
	#parsing part
	my ($from, $to) = @_;
	
	chdir $from;
	
	my @files = ();
	find(sub { 
		if(-f -e $_ && $_ =~ /\.java$/) {
			my %info = read_java_file();
			@info{'file'} = $File::Find::name;
			push @files, \%info; 
		}
	}, './');
	
	#saving part
	mkdir $to;
	chdir $to;
	
	my $package = @{@files[0]}{'package'};
	my $dir = dirname(@{@files[0]}{'file'});
	
	#list of enums as they require special converters
	my @enums = ();
	foreach(@files) {
		if(@$_{'type'} eq 'enum') {
			push @enums, @$_{'name'};
		}
	}
	
	#add parent object reference to child to be able to get parent info
	foreach(@files) {
		if(@$_{'type'} eq 'class' && defined @$_{'parentclass'}) {
			my $child_ref = $_;
			foreach(@files) {
				if(@$_{'name'} eq @$child_ref{'parentclass'}) {
					@$child_ref{'parent'} = $_;
					@$_{'is_parent'} = 1;
					last;
				}
			}
		}
	}
	
	#go through all files and save converted classes
	foreach(@files) {
		my $tofile = (@$_{'file'} =~ /^(.*\.)java$/)[0]."kt";
		my $ktcode = "";
		
		my $info_ref = $_;
		my $type = @$_{'type'}; #weired enough can't use dereference directly in 'given'
		given($type) {
			when('class') {
				$ktcode = get_class_code_kt($info_ref, \@enums);
			}
			when('enum') {
				$ktcode = get_enum_code_kt($info_ref);
			}
			default {
				print "java code type not matching. skipping @$info_ref{'file'}\n";
				next;
			}
		}
		make_path(dirname($tofile));
		open(my $fh_out, '>', $tofile) or die("unable to create file to write");
		print $fh_out $ktcode;
		close($fh_out);
	}
	
	# additional converters for known classes that are of simple type
	my @converters = ();
	foreach(@additionalConverters) {
		given($_) {
			when('BigDecimal') {
				my @conv = (
				$_,
				"import java.math.BigDecimal",
				"        return value.toPlainString()",
				"        return if(value.isEmpty()) null else BigDecimal(value)");
				push @converters, \@conv;
			}
			default {
				my $warn = 1;
				my $name = $_;
				foreach(@files) {
					if (@$_{'name'} eq $name) { $warn = 0; last; }
				}
				next if(!$warn);
				print "WARNING: UNKNOWN TYPE TO CONVERT: $_ \n";
			}
		}
	}
	
	if(@converters) {	
		foreach(@converters) {
			my $file = File::Spec->catfile($dir, @$_[0]."Converter.kt");
			my $ktcode = "package $package\n".
				"\n".
				"import com.tickaroo.tikxml.TypeConverter\n".
				@$_[1]."\n".
				"\n".
				"class @$_[0]Converter: TypeConverter<@$_[0]> {\n".
				"    override fun write(value: @$_[0]): String {\n".
				@$_[2]."\n".
				"    }\n".
				"    \n".
				"    override fun read(value: String): @$_[0]? {\n".
				@$_[3]."\n".
				"    }\n".
				"}\n";
			
			open(my $fh_out, '>', $file);
			print $fh_out $ktcode;
			close($fh_out);
		}
	}
	
	# add extension for TikXml.Builder to add TypeAdapters of enums
	if(@enums) {
		my $file = File::Spec->catfile($dir, "extensions.kt");
		
		my @imports = (
			"import com.tickaroo.tikxml.TikXml"
		);
		my @singleExtensions = ();
		my @chainedCalls = ();
		foreach(@enums) {
			push @singleExtensions, 
				"inline fun TikXml.Builder.add".$_."Adapter() =\n".
				"    addTypeAdapter(".$_."::class.java, $_.Adapter())";
			push @chainedCalls, "add".$_."Adapter()";
		}
		
		my $ktcode = "package $package\n".
			"\n".
			join("\n", uniq(@imports))."\n".
			"\n".
			join("\n\n", @singleExtensions)."\n\n".
			"fun TikXml.Builder.addEnumAdapters() =\n".
			"    ".join("\n    .", @chainedCalls)."\n";
		
		open(my $fh_out, '>', $file);
		print $fh_out $ktcode;
		close($fh_out);
	}
};

# param in $file - file containing java xml object model
# return: %(type, name, code, package, namealias, <...type specific>) or %() if not xml element
sub read_java_file 
{
	open(my $fh, '<', $_) or die("not found $_");
	my $code = do { local $/; <$fh> };
	close($fh);
	if (!($code =~ /\@XmlType/)) { return (); }
	my ($package) = $code =~ /package ([\w\.]+);/;
	my ($classalias) = $code =~ /\@(?:XmlType|XmlRootElement)\(name = \"(\w+)\"/;
	my ($type, $classname) = $code =~ /public ((?:class|enum)) (\w+)/;
	my %info = (
		'package' => $package,
		'type' => $type,
		'name' => $classname,
		'alias' => $classalias,
		'code' => $code
	);
	given($type) {
		when('class') { extract_class_info(\%info); }
		when('enum') { extract_enum_info(\%info); }
	}
	return %info;
};

# param in/out \%info - reference to map where additional info about class will be stored
sub extract_class_info
{
	my $code = @{$_[0]}{'code'};
	my ($parentclass) = $code =~ /extends (\w+)/;

	my @props = ();
	foreach($code =~ m/((?:\@XmlElement|protected)[^;]+);/g) {
		my ($alias, $required, $nillable, $type, $name) = $_ =~ /^(?:\@XmlElement\((?:name = \"(\w+)\"|)((?:, |)required = true)?((?:, |)nillable = true)?\).*protected|protected) ([\w<>]+) (\w+)$/s;
		my $simpletype = is_java_simple_type($type);
		my %arr = ( 
			'alias' => $alias,
			'required' => (($simpletype || defined $required) or 0),
			'nillable' => ((!$simpletype && defined $nillable) or 0),
			'type' => $type,
			'name' => $name
			);
		push @props, \%arr;
	}
	
	@{$_[0]}{'parentclass'} = $parentclass;
	@{$_[0]}{'props'} = \@props;
};

# param in $type - name of java type
sub is_java_simple_type
{
	return $_[0] =~ /^(?:byte|char|short|int|long|float|double|boolean)$/;
};

# param in \%info - reference to map of informations about this class
# param in \@enums - reference to list of all enum names
sub get_class_code_kt 
{
	my %info = %{$_[0]};
	my @enums = @{$_[1]};
	my @imports = (
		"import com.tickaroo.tikxml.annotation.Xml"
	);
	my @props = ();
	my ($i, $p) = create_props_kt(@info{'props'}, $_[1], 1);
	push @imports, @$i;
	push @props, @$p;
	if (@info{'parent'}) { 
		my ($i, $p) = create_props_kt(@info{'parent'}->{'props'}, $_[1], 0);
		push @imports, @$i;
		push @props, @$p;
	}
	
	my @parent_params = ();
	if (@info{'parent'}) {
		foreach(@{@info{'parent'}->{'props'}}) {
			push @parent_params, @$_{'name'};
		}
	}
	
	my @mainAnnotationParams = ();
	if (@info{'name'} ne @info{'alias'}) { push @mainAnnotationParams, "name = \"@info{'alias'}\""; }

	my $tabulation = 7+length(@info{'name'});
	if (@info{'is_parent'}) { $tabulation += 5; }
	my $ktcode = 
		"package @info{'package'}\n".
		"\n".
		join("\n", uniq(@imports))."\n".
		"\n".
		"\@Xml".(@mainAnnotationParams ? "(".join(', ', @mainAnnotationParams).")": '')."\n".
		(@info{'is_parent'}?"open ":"")."class @info{'name'}(".join(",\n".(" " x $tabulation), @props).")".(@info{'parentclass'} ? " : @info{'parentclass'}(".join(', ', @parent_params).")":"")."\n"; 
	return $ktcode;
};
#param in @props - list of properies details
#param in @enums - list of enum names
#param in $fields - make them as fields, or as parameters
sub create_props_kt
{
	my @enums = @{$_[1]};
	my $as_field = $_[2];
	my @imports = ();
	my @props = ();
	foreach(@{$_[0]}) {
		my %prop = %$_;
		my $optional = !@prop{'required'} || @prop{'nillable'};

		my @ktype = define_kt_type(@prop{'type'}, @prop{'required'} && !@prop{'nillable'}, \@enums);
		push(@imports, @ktype[1]);
		push(@imports, "import com.tickaroo.tikxml.annotation.".(@ktype[0]?"Property":"")."Element");
		
		my $name = @prop{'name'};
		if (@ktype[2] ne 'Boolean' && $name =~ /^is/) {
			$name = lcfirst(($name =~ /^is(.*)$/)[0]);
		}
		
		my @annotationProps = ();
		my $annotation = @ktype[0] ? "\@PropertyElement" : "\@Element";
		if(defined @prop{'alias'} && @prop{'alias'} ne $name) { push @annotationProps, "name = \"@prop{'alias'}\""; }
		if(@ktype[3] ne "") { push @annotationProps, "converter = @ktype[3]"; }
		my $prop_code = $annotation.(@annotationProps?'('.join(', ', @annotationProps).')':'').($as_field?" val":"")." $name: @ktype[2]";
		push(@props, $prop_code);
	}
	return ( \@imports, \@props);
};

# convert Java-types to Kotlin-Types allowing also for custom import
# param in $type - name of java type
# param in $required - if type cannot be nillable
# param in \@enums - reference to list of enum names, as they require additional converters
# return @type : ($is_simple_type, $additional_import, $kt_type, $converter) 
sub define_kt_type
{
	my @enums = @{$_[2]};
	my $rawtype = $_[0];
	my $appendix = ($_[1] ? "" : "?");
	my $original = $_[0].$appendix;
	given($_[0]) {
		when('boolean') { return (1, "", "Boolean", ""); }
		when('Boolean') { return (1, "", "Boolean?", ""); }
		when('BigDecimal') {
			push @additionalConverters, $_;
			return (1, "import java.math.BigDecimal", $original, "BigDecimalConverter::class"); 
		} 
		when('int') { return (1, "", "Int", ""); }
		when('Integer') { return (1, "", "Int?", ""); }
		when('long') { return (1, "", "Long", ""); }
		when('String') { return (1, "", $original, ""); }
		when('XMLGregorianCalendar') { return (1, "import java.util.Date", "Date$appendix", ""); }
		when(/List<\w+>/) { return (0, "", "List<\@JvmSuppressWildcards ".(($_ =~ /<(\w+)>/)[0]).">".$appendix, ""); }
		default {
			if (grep(/^$rawtype$/, @enums) or 0) {
				#use given enum converter
				return (1, "", $original, "$_.Converter::class");
			}
			push @additionalConverters, $_;
			return (0, "", $original, "");
		}
	}
};

# param in/out \%info - reference to map where additional info about enum will be stored
sub extract_enum_info
{
	my $code = @{$_[0]}{'code'};

	my @values = ();
	foreach($code =~ m/(\@XmlEnumValue[^,;]+)(?:,|;)/g) {
		my ($alias, $name) = $_ =~ /^\@XmlEnumValue\(\"(\w+)\"\)\s+([\w]+)\(\"\w+\"\)$/s;
		my %arr = ( 
			'name' => $name,
			'alias' => $alias
			);
		push @values, \%arr;
	}
	
	@{$_[0]}{'values'} = \@values;
};

# param in \%info - reference to map of informations about this enum
sub get_enum_code_kt
{
	my %info = %{$_[0]};
	my @imports = (
		"import com.tickaroo.tikxml.TikXmlConfig",
		"import com.tickaroo.tikxml.TypeConverter",
		"import com.tickaroo.tikxml.XmlReader",
		"import com.tickaroo.tikxml.XmlWriter",
		"import com.tickaroo.tikxml.typeadapter.TypeAdapter"
	);
	my @props = ();
	my @write_conditions = ();
	my @read_conditions = ();
	foreach(@{@info{'values'}}) {
		my $name = %$_{'name'};
		my $alias = %$_{'alias'};
		push @props, $name;
		push @write_conditions, "$name -> \"$alias\"";
		push @read_conditions, "\"$alias\" -> $name";
	}
	push @read_conditions, "else -> null";
	my $ktcode = 
		"package @info{'package'}\n".
		"\n".
		join("\n", uniq(@imports))."\n".
		"\n".
		"enum class @info{'name'} {\n".
		"    ".join(",\n    ", @props).";\n".
		"\n".
		"    class Converter: TypeConverter<@info{'name'}> {\n".
		"        override fun write(value: @info{'name'}): String {\n".
		"            return when (value) {\n".
		"                ".join("\n                ", @write_conditions)."\n".
		"            }\n".
		"        }\n".
		"\n".
		"        override fun read(value: String): @info{'name'}? {\n".
		"            return when (value) {\n".
		"                ".join("\n                ", @read_conditions)."\n".
		"            }\n".
		"        }\n".
		"    }\n".
		"\n".
		"    class Adapter : TypeAdapter<@info{'name'}> {\n".
		"        private val converter = Converter()\n".
		"\n".
		"        override fun toXml(\n".
		"            writer: XmlWriter,\n".
		"            config: TikXmlConfig,\n".
		"            value: @info{'name'},\n".
		"            overridingXmlElementTagName: String?\n".
		"        ) {\n".
		"            writer.beginElement(overridingXmlElementTagName ?: \"@info{'name'}\")\n".
		"            writer.textContent(converter.write(value))\n".
		"            writer.endElement()\n".
		"        }\n".
		"\n".
		"        override fun fromXml(reader: XmlReader, config: TikXmlConfig): @info{'name'}? {\n".
		"            while (reader.hasAttribute()) reader.skipAttribute()\n".
		"            while (reader.hasElement()) reader.skipRemainingElement()\n".
		"            val item = reader.nextTextContent()?.let { converter.read(it) }\n".
		"            return item\n".
		"        }\n".
		"    }\n".
		"}\n";
	return $ktcode;
};

# create list of only unique values from given list argument
sub uniq
{ 
	my %seen = ( "" => 1);
	my @unique = ();
	foreach my $value (@_) {
	  if (! $seen{$value}) {
		push @unique, $value;
		$seen{$value} = 1;
	  }
	}
	return @unique;
};
