#!/usr/bin/perl
use v5.14;
use strict;
use Data::Dumper;
use File::Basename;
use File::Path qw/make_path/;
use File::Find;
use File::Spec;
no warnings 'experimental';

if (!defined @ARGV[0]) {
	print "please provide folder with java models generated by wsimport tool";
	exit -1;
}
{ #scope for not leaking global vars
my $path = File::Spec->canonpath(@ARGV[0]);
my $root = dirname($path);
my $dir = basename($path);
my $ktdir = File::Spec->catdir($root, $dir."_kt");

main(File::Spec->catdir($root, $dir), $ktdir);
print "\nclasses generated into $ktdir.\nRemember to add generated TypeAdapters with your instance of TikXml.\n\n\tTikXml.Builder().addModelAdapters().build()\n\n";
}
exit 0; #just an indicator that there is no global code after this point

my @additionalConverters = ();
my @additionalAdapters = ();

# param in $dir - directory where are generated java classes. directory structure will be copied.
sub main
{
	#parsing part
	my ($from, $to) = @_;
	
	chdir $from;
	
	my @files = ();
	find(sub { 
		if(-f -e $_ && $_ =~ /\.java$/) {
			my %info = read_java_file();
			@info{'file'} = $File::Find::name;
			push @files, \%info; 
		}
	}, './');
	
	#saving part
	mkdir $to;
	chdir $to;
	
	my $package = @{@files[0]}{'package'};
	my $dir = dirname(@{@files[0]}{'file'});
	
	#list of enums as they require special converters
	my @enums = ();
	foreach(@files) {
		if(@$_{'type'} eq 'enum') {
			push @enums, @$_{'name'};
		}
	}
	
	#add parent object reference to child to be able to get parent info
	foreach(@files) {
		if(@$_{'type'} eq 'class' && defined @$_{'parentclass'}) {
			my $child_ref = $_;
			foreach(@files) {
				if(@$_{'name'} eq @$child_ref{'parentclass'}) {
					@$child_ref{'parent'} = $_;
					@$_{'is_parent'} = 1;
					last;
				}
			}
		}
	}
	
	#go through all files and save converted classes
	foreach(@files) {
		my $tofile = (@$_{'file'} =~ /^(.*\.)java$/)[0]."kt";
		my $ktcode = "";
		
		my $info_ref = $_;
		my $type = @$_{'type'}; #weired enough can't use dereference directly in 'given'
		given($type) {
			when('class') {
				$ktcode = get_class_code_kt($info_ref, \@enums);
			}
			when('enum') {
				$ktcode = get_enum_code_kt($info_ref);
			}
			default {
				print "java code type not matching. skipping @$info_ref{'file'}\n";
				next;
			}
		}
		make_path(dirname($tofile));
		open(my $fh_out, '>', $tofile) or die("unable to create file to write");
		print $fh_out $ktcode;
		close($fh_out);
	}
	
	# additional converters 
	# - for known classes that are of "simple" type (write to single string, like BigDecimal)
	foreach(uniq(@additionalConverters)) {
		my $import = "";
		my $write = "";
		my $read = "";
		given($_) {
			when('BigDecimal') {
				$import = "import java.math.BigDecimal";
				$write = "        return value.toPlainString()";
				$read = "        return if(value.isEmpty()) null else BigDecimal(value)";
			}
			when('Date') {
				print "     ****\n     INFO: Make sure to include your Date converter of choice to TikXml config. If you don't know what to choose, check out com.tickaroo.tikxml:converter-date-rfc3339 official converter.\n     ****\n\n";
				next;
			}
			when('String') { next; } #skip
			when('Int') { next; } #skip
			when('Boolean') { next; } #skip
			default {
				my $warn = 1;
				my $name = $_;
				foreach(@files) {
					if (@$_{'name'} eq $name) { $warn = 0; last; }
				}
				next if(!$warn);
				print "WARNING: UNKNOWN TYPE TO CONVERT: $_ \n";
				next;
			}
		}
		my $file = File::Spec->catfile($dir, $_."Converter.kt");
		my $ktcode = "package $package\n".
			"\n".
			"import com.tickaroo.tikxml.TypeConverter\n".
			"$import\n".
			"\n".
			"class ".$_."Converter: TypeConverter<$_> {\n".
			"    override fun write(value: $_): String {\n".
			"$write\n".
			"    }\n".
			"    \n".
			"    override fun read(value: String): $_? {\n".
			"$read\n".
			"    }\n".
			"}\n";

		open(my $fh_out, '>', $file);
		print $fh_out $ktcode;
		close($fh_out);
	}
	
	# add generic class for using converter from TikXmlConfig inside TypeAdapter
	if (@additionalAdapters || @enums) {
		my $file = File::Spec->catfile($dir, "ConverterTypeAdapter.kt");
		my @imports = ();
		
		my $ktcode = "package $package\n".
			"\n".
			"import com.tickaroo.tikxml.*\n".
			"import com.tickaroo.tikxml.typeadapter.TypeAdapter\n".
			"\n".
			"class ConverterTypeAdapter<T>(\n".
			"    private val clazz: Class<T>,\n".
			"    private val converter: TypeConverter<T>?\n".
			") : TypeAdapter<T> {\n".
			"    override fun fromXml(reader: XmlReader, config: TikXmlConfig): T {\n".
			"        while (reader.hasAttribute()) reader.skipAttribute()\n".
			"        while (reader.hasElement()) reader.skipRemainingElement()\n".
			"        check(reader.hasTextContent()) { \"text content not found for parsing \${clazz.simpleName}\" }\n".
			"        return (converter ?: config.getTypeConverter(clazz)).read(reader.nextTextContent())\n".
			"    }\n".
			"\n".
			"    override fun toXml(\n".
			"        writer: XmlWriter,\n".
			"        config: TikXmlConfig,\n".
			"        value: T,\n".
			"        overridingXmlElementTagName: String?\n".
			"    ) {\n".
			"        writer.beginElement(overridingXmlElementTagName ?: clazz.simpleName)\n".
			"        writer.textContent((converter ?: config.getTypeConverter(clazz)).write(value))\n".
			"        writer.endElement()\n".
			"    }\n".
			"}\n";

		open(my $fh_out, '>', $file);
		print $fh_out $ktcode;
		close($fh_out);
	}
	
	# additional adapters
	# - for primitives used in lists
	# - for enums (only ones used in lists)
	if (@additionalAdapters) {
		#saved to single file for simplicity of this script
		my $file = File::Spec->catfile($dir, "TikXmlAdapters.kt");
		
		my @imports = ();
		push @imports, "import com.tickaroo.tikxml.TikXml";
		my @classes = ();
		my @chainedCalls = ();
		my $writeSimple = 0;
		
		#param in $type - Kotlin type
		#param in $class - whole package or just name
		#param in $read - way of reading value from XmlReader
		#param in $write - way of saving value to XmlWriter
		sub get_simple_adapter_chain_call
		{
			my ($type, $clazz, $read, $write) = @_;
			return "addTypeAdapter(\n".
					"        ".$clazz."::class.java,\n".
					"        simpleValueAdapter<$type>(\n".
					"            { $read },\n".
					"            { it, value -> $write })\n".
					"    )";
		}
		
		foreach(uniq(@additionalAdapters)) {
			given($_) {
				when('Boolean') {
					$writeSimple = 1;
					push @chainedCalls, get_simple_adapter_chain_call(
						'Boolean',
						'java.lang.Boolean',
						'it.textContent(value)', 
						'it.nextTextContentAsBoolean()');
					next;
				}
				when('BigDecimal') {
					push @chainedCalls, "addTypeAdapter(\n".
						"        java.math.BigDecimal::class.java,\n".
						"        ConverterTypeAdapter(java.math.BigDecimal::class.java, BigDecimalConverter())\n".
						"    )";
					next;
				}
				when('Int') {
					$writeSimple = 1;
					push @chainedCalls, get_simple_adapter_chain_call(
						'Int',
						'java.lang.Integer',
						'it.textContent(value)',
						'it.nextTextContentAsInt()');
					next;
				}
				when('String') {
					$writeSimple = 1;
					push @chainedCalls, get_simple_adapter_chain_call(
						'String',
						'java.lang.String',
						'it, value -> it.textContent(value)',
						'it.nextTextContent()');
					next;
				}
				when('Date') {
					push @chainedCalls, "addTypeAdapter(\n".
						"        java.util.Date::class.java,\n".
						"        ConverterTypeAdapter(java.util.Date::class.java, null /* use otherwise provided converter */)\n".
						"    )";
					next;
				}
				default {
					my $s = $_;
					if (!grep(/^$s$/, @enums)) {
						print "WARNING: UNKNOWN TYPE FOR ADAPTER: $_ \n";
						next;
					}
					#handle enum
					push @chainedCalls, "addTypeAdapter(\n".
						"        ".$_."::class.java,\n".
						"        ConverterTypeAdapter(".$_."::class.java, ".$_.".Converter())\n".
						"    )";
				}
			}
	
		}
		
		if ($writeSimple) {
			push @imports, "import com.tickaroo.tikxml.TikXml";
			push @imports, "import com.tickaroo.tikxml.TikXmlConfig";
			push @imports, "import com.tickaroo.tikxml.XmlReader";
			push @imports, "import com.tickaroo.tikxml.XmlWriter";
			push @imports, "import com.tickaroo.tikxml.typeadapter.TypeAdapter";
			push @classes, "private inline fun <reified T> simpleValueAdapter(\n".
				"    crossinline read: (XmlReader) -> T,\n".
				"    crossinline write: (XmlWriter, T) -> Unit\n".
				") = object : TypeAdapter<T> {\n".
				"    override fun fromXml(reader: XmlReader, config: TikXmlConfig): T {\n".
				"        while (reader.hasAttribute()) reader.skipAttribute()\n".
				"        while (reader.hasElement()) reader.skipRemainingElement()\n".
				"        check(reader.hasTextContent()) { \"text content not found for parsing \${T::class.java}\" }\n".
				"        val ret = read(reader)\n".
				"        return ret\n".
				"    }\n".
				"\n".
				"    override fun toXml(\n".
				"        writer: XmlWriter,\n".
				"        config: TikXmlConfig,\n".
				"        value: T,\n".
				"        overridingXmlElementTagName: String?\n".
				"    ) {\n".
				"        writer.beginElement(overridingXmlElementTagName ?: \"item\")\n".
				"        write(writer, value)\n".
				"        writer.endElement()\n".
				"    }\n".
				"}\n";
		}
		
		my $ktcode = "package $package\n".
			"\n".
			(@imports ? join("\n", uniq(@imports))."\n" : "").
			"\n".
			(@classes ? join("\n", @classes)."\n\n" : "").
			"fun TikXml.Builder.addModelAdapters() =\n".
			"    ".join(".", @chainedCalls)."\n";

		open(my $fh_out, '>', $file);
		print $fh_out $ktcode;
		close($fh_out);
	}
};

# param in $file - file containing java xml object model
# return: %(type, name, code, package, namealias, <...type specific>) or %() if not xml element
sub read_java_file 
{
	open(my $fh, '<', $_) or die("not found $_");
	my $code = do { local $/; <$fh> };
	close($fh);
	if (!($code =~ /\@XmlType/)) { return (); }
	my ($package) = $code =~ /package ([\w\.]+);/;
	my ($classalias) = $code =~ /\@(?:XmlType|XmlRootElement)\(name = \"(\w+)\"/;
	my ($type, $classname) = $code =~ /public ((?:class|enum)) (\w+)/;
	my %info = (
		'package' => $package,
		'type' => $type,
		'name' => $classname,
		'alias' => $classalias,
		'code' => $code
	);
	given($type) {
		when('class') { extract_class_info(\%info); }
		when('enum') { extract_enum_info(\%info); }
	}
	return %info;
};

# param in/out \%info - reference to map where additional info about class will be stored
sub extract_class_info
{
	my $code = @{$_[0]}{'code'};
	my ($parentclass) = $code =~ /extends (\w+)/;

	my @props = ();
	foreach($code =~ m/((?:\@XmlElement|protected)[^;]+);/g) {
		my ($alias, $required, $nillable, $type, $name) = $_ =~ /^(?:\@XmlElement\((?:name = \"(\w+)\"|)((?:, |)required = true)?((?:, |)nillable = true)?\).*protected|protected) ([\w<>]+) (\w+)$/s;
		my $simpletype = is_java_simple_type($type);
		my %arr = ( 
			'alias' => $alias,
			'required' => (($simpletype || defined $required) or 0),
			'nillable' => ((!$simpletype && defined $nillable) or 0),
			'type' => $type,
			'name' => $name
			);
		push @props, \%arr;
	}
	
	@{$_[0]}{'parentclass'} = $parentclass;
	@{$_[0]}{'props'} = \@props;
};

# param in $type - name of java type
sub is_java_simple_type
{
	return $_[0] =~ /^(?:byte|char|short|int|long|float|double|boolean)$/;
};

# param in \%info - reference to map of informations about this class
# param in \@enums - reference to list of all enum names
sub get_class_code_kt 
{
	my %info = %{$_[0]};
	my @enums = @{$_[1]};
	my @imports = (
		"import com.tickaroo.tikxml.annotation.Xml"
	);
	my @props = ();
	my ($i, $p) = create_props_kt(@info{'props'}, $_[1], 1);
	push @imports, @$i;
	push @props, @$p;
	if (@info{'parent'}) { 
		my ($i, $p) = create_props_kt(@info{'parent'}->{'props'}, $_[1], 0);
		push @imports, @$i;
		push @props, @$p;
	}
	
	my @parent_params = ();
	if (@info{'parent'}) {
		foreach(@{@info{'parent'}->{'props'}}) {
			push @parent_params, @$_{'name'};
		}
	}
	
	my @mainAnnotationParams = ();
	if (@info{'name'} ne @info{'alias'}) { push @mainAnnotationParams, "name = \"@info{'alias'}\""; }

	my $tabulation = 7+length(@info{'name'});
	if (@info{'is_parent'}) { $tabulation += 5; }
	my $ktcode = 
		"package @info{'package'}\n".
		"\n".
		join("\n", uniq(@imports))."\n".
		"\n".
		"\@Xml".(@mainAnnotationParams ? "(".join(', ', @mainAnnotationParams).")": '')."\n".
		(@info{'is_parent'}?"open ":"")."class @info{'name'}(".join(",\n".(" " x $tabulation), @props).")".(@info{'parentclass'} ? " : @info{'parentclass'}(".join(', ', @parent_params).")":"")."\n"; 
	return $ktcode;
};
#param in @props - list of properies details
#param in @enums - list of enum names
#param in $fields - make them as fields, or as parameters
sub create_props_kt
{
	my @enums = @{$_[1]};
	my $as_field = $_[2];
	my @imports = ();
	my @props = ();
	foreach(@{$_[0]}) {
		my %prop = %$_;
		my $optional = !@prop{'required'} || @prop{'nillable'};

		my @ktype = define_kt_type(@prop{'type'}, @prop{'required'} && !@prop{'nillable'}, \@enums);
		push(@imports, @ktype[1]);
		push(@imports, "import com.tickaroo.tikxml.annotation.".(@ktype[0]?"Property":"")."Element");
		
		my $name = @prop{'name'};
		if (@ktype[2] ne 'Boolean' && $name =~ /^is/) {
			$name = lcfirst(($name =~ /^is(.*)$/)[0]);
		}
		
		my @annotationProps = ();
		my $annotation = @ktype[0] ? "\@PropertyElement" : "\@Element";
		if(defined @prop{'alias'} && @prop{'alias'} ne $name) { push @annotationProps, "name = \"@prop{'alias'}\""; }
		if(@ktype[3] ne "") { push @annotationProps, "converter = @ktype[3]"; }
		my $prop_code = $annotation.(@annotationProps?'('.join(', ', @annotationProps).')':'').($as_field?" val":"")." $name: @ktype[2]";
		push(@props, $prop_code);
	}
	return ( \@imports, \@props);
};

# convert Java-types to Kotlin-Types allowing also for custom import
# param in $type - name of java type
# param in $required - if type cannot be nillable
# param in \@enums - reference to list of enum names, as they require additional converters
# return @type : ($is_simple_type, $additional_import, $kt_type, $converter) 
sub define_kt_type
{
	my @enums = @{$_[2]};
	my $rawtype = $_[0];
	my $appendix = ($_[1] ? "" : "?");
	my $original = $_[0].$appendix;
	given($_[0]) {
		when('boolean') { return (1, "", "Boolean", ""); }
		when('Boolean') { return (1, "", "Boolean$appendix", ""); }
		when('BigDecimal') {
			push @additionalConverters, $_;
			return (1, "import java.math.BigDecimal", $original, "BigDecimalConverter::class"); 
		} 
		when('int') { return (1, "", "Int", ""); }
		when('Integer') { return (1, "", "Int?", ""); }
		when('long') { return (1, "", "Long", ""); }
		when('String') { return (1, "", "String$appendix", ""); }
		when('XMLGregorianCalendar') { 
			push @additionalConverters, "Date";
			return (1, "import java.util.Date", "Date$appendix", "");
		}
		when(/List<\w+>/) { 
			my $subtype = ($_ =~ /<(\w+)>/)[0];
			my $subtypekt = "";
			my $import = "";
			given($subtype) { #for known boxed primitives we need to create TypeAdapter that will read value
				when('Boolean') {
					$subtypekt = "Boolean";
					push @additionalAdapters, $subtypekt;
				}
				when('BigDecimal') {
					$subtypekt = $_;
					$import = "import java.math.BigDecimal";
					push @additionalConverters, $subtypekt;
					push @additionalAdapters, $subtypekt;
				}
				when('Integer') {
					$subtypekt = "Int";
					push @additionalAdapters, $subtypekt;
				}
				when('String') {
					$subtypekt = "String";
					push @additionalAdapters, $subtypekt;
				}
				when('XMLGregorianCalendar') {
					$subtypekt = "Date";
					$import = "import java.util.Date";
					push @additionalConverters, $subtypekt;
					push @additionalAdapters, $subtypekt;
				}
				default {
					$subtypekt = $subtype;
					if (grep(/^$subtypekt$/, @enums) or 0) {
						push @additionalAdapters, $subtypekt;
					}
				}
			}
			return (0, $import, "List<\@JvmSuppressWildcards $subtypekt>".$appendix, ""); 
		}
		default {
			if (grep(/^$rawtype$/, @enums) or 0) {
				#use given enum converter
				return (1, "", $original, "$_.Converter::class");
			}
			push @additionalConverters, $_;
			return (0, "", $original, "");
		}
	}
};

# param in/out \%info - reference to map where additional info about enum will be stored
sub extract_enum_info
{
	my $code = @{$_[0]}{'code'};

	my @values = ();
	foreach($code =~ m/(\@XmlEnumValue[^,;]+)(?:,|;)/g) {
		my ($alias, $name) = $_ =~ /^\@XmlEnumValue\(\"(\w+)\"\)\s+([\w]+)\(\"\w+\"\)$/s;
		my %arr = ( 
			'name' => $name,
			'alias' => $alias
			);
		push @values, \%arr;
	}
	
	@{$_[0]}{'values'} = \@values;
};

# param in \%info - reference to map of informations about this enum
sub get_enum_code_kt
{
	my %info = %{$_[0]};
	my @imports = (
		"import com.tickaroo.tikxml.TikXmlConfig",
		"import com.tickaroo.tikxml.TypeConverter",
		"import com.tickaroo.tikxml.XmlReader",
		"import com.tickaroo.tikxml.XmlWriter",
		"import com.tickaroo.tikxml.typeadapter.TypeAdapter"
	);
	my @props = ();
	my @write_conditions = ();
	my @read_conditions = ();
	foreach(@{@info{'values'}}) {
		my $name = %$_{'name'};
		my $alias = %$_{'alias'};
		push @props, $name;
		push @write_conditions, "$name -> \"$alias\"";
		push @read_conditions, "\"$alias\" -> $name";
	}
	push @read_conditions, "else -> null";
	my $ktcode = 
		"package @info{'package'}\n".
		"\n".
		join("\n", uniq(@imports))."\n".
		"\n".
		"enum class @info{'name'} {\n".
		"    ".join(",\n    ", @props).";\n".
		"\n".
		"    class Converter: TypeConverter<@info{'name'}> {\n".
		"        override fun write(value: @info{'name'}): String {\n".
		"            return when (value) {\n".
		"                ".join("\n                ", @write_conditions)."\n".
		"            }\n".
		"        }\n".
		"\n".
		"        override fun read(value: String): @info{'name'}? {\n".
		"            return when (value) {\n".
		"                ".join("\n                ", @read_conditions)."\n".
		"            }\n".
		"        }\n".
		"    }\n".
		"}\n";
	return $ktcode;
};

# create list of only unique values from given list argument
sub uniq
{ 
	my %seen = ( "" => 1);
	my @unique = ();
	foreach my $value (@_) {
	  if (! $seen{$value}) {
		push @unique, $value;
		$seen{$value} = 1;
	  }
	}
	return @unique;
};
