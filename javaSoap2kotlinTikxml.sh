#!/usr/bin/perl
use v5.14;
use strict;
use Data::Dumper;
use File::Basename;
use File::Path;
use File::Find;
use File::Spec;
no warnings 'experimental';

if (!defined @ARGV[0]) {
	print "please provide folder with java models generated by wsimport tool";
	exit -1;
}
{ #scope for not leaking global vars
my $path = File::Spec->canonpath(@ARGV[0]);
my $root = dirname($path);
my $dir = basename($path);
my $ktdir = File::Spec->catdir($root, $dir."_kt");

main(File::Spec->catdir($root, $dir), $ktdir);
}
exit 0; #just an indicator that there is no global code after this point

my @additionalConverters = ();

# param in $dir - directory where are generated java classes. directory structure will be copied.
sub main
{
	#parsing part
	my ($from, $to) = @_;
	
	chdir $from;
	
	my @files = ();
	find(sub { 
		if(-f -e $_ && $_ =~ /\.java$/) {
			my %info = read_java_file();
			@info{'file'} = $File::Find::name;
			push @files, \%info; 
		}
	}, './');
	
	#saving part
	mkdir $to;
	chdir $to;
	
	#list of enums as they require special converters
	my @enums = ();
	foreach(@files) {
		if(@$_{'type'} eq 'enum') {
			push @enums, @$_{'name'};
		}
	}
	
	#add parent object reference to child to be able to get parent info
	foreach(@files) {
		if(@$_{'type'} eq 'class' && defined @_{'parentclass'}) {
			my $child_ref = $_;
			foreach(@files) {
				if(@$_{'name'} eq @$child_ref{'parentclass'}) {
					@$child_ref{'parent'} = $_;
					last;
				}
			}
		}
	}
	
	#go through all files and save converted classes
	foreach(@files) {
		my $tofile = (@$_{'file'} =~ /^(.*\.)java$/)[0]."kt";
		my $ktcode = "";
		
		my $info_ref = $_;
		my $type = @$_{'type'}; #weired enough can't use dereference directly in 'given'
		given($type) {
			when('class') {
				$ktcode = get_class_code_kt($info_ref, \@enums);
			}
			when('enum') {
				$ktcode = get_enum_code_kt($info_ref);
			}
			default {
				print "java code type not matching. skipping @$info_ref{'file'}\n";
				next;
			}
		}
		open(my $fh_out, '>', $tofile);
		print $fh_out $ktcode;
		close($fh_out);
	}
	
	# additional converters for known classes that are of simple type
	my @converters = ();
	foreach(@additionalConverters) {
		given($_) {
			when('BigDecimal') {
				my @conv = (
				$_,
				"import java.math.BigDecimal",
				"\t\treturn value.toPlainString()",
				"\t\treturn if(value.isEmpty()) null else BigDecimal(value)");
				push @converters, \@conv;
			}
			default {
				print "WARNING: UNKNOWN TYPE TO CONVERT: $_ \n";
			}
		}
	}
	
	if(scalar @converters > 0) {	
		my $package = @{@files[0]}{'package'};
		my $dir = dirname(@{@files[0]}{'file'});
		
		foreach(@converters) {
			my $file = File::Spec->catfile($dir, @$_[0]."Converter.kt");
		
			my $ktcode = "package $package\n".
				"\n".
				"import com.tickaroo.tikxml.TypeConverter\n".
				@$_[1]."\n".
				"\n".
				"class @$_[0]Converter: TypeConverter<@$_[0]> {\n".
				"	override fun write(value: @$_[0]): String {\n".
				@$_[2]."\n".
				"	}\n".
				"	\n".
				"	override fun read(value: String): @$_[0]? {\n".
				@$_[3]."\n".
				"	}\n".
				"}\n";
			
			open(my $fh_out, '>', $file);
			print $fh_out $ktcode;
			close($fh_out);
			
		}
	}
};

# param in $file - file containing java xml object model
# return: %(type, name, code, package, namealias, <...type specific>) or %() if not xml element
sub read_java_file 
{
	open(my $fh, '<', $_) or die("not found $_");
	my $code = do { local $/; <$fh> };
	close($fh);
	if (!($code =~ /\@XmlType/)) { return (); }
	my ($package) = $code =~ /package ([\w\.]+);/;
	my ($classalias) = $code =~ /\@(?:XmlType|XmlRootElement)\(name = \"(\w+)\"/;
	my ($type, $classname) = $code =~ /public ((?:class|enum)) (\w+)/;
	my %info = (
		'package' => $package,
		'type' => $type,
		'name' => $classname,
		'alias' => $classalias,
		'code' => $code
	);
	given($type) {
		when('class') { extract_class_info(\%info); }
		when('enum') { extract_enum_info(\%info); }
	}
	return %info;
};

# param in/out \%info - reference to map where additional info about class will be stored
sub extract_class_info
{
	my $code = @{$_[0]}{'code'};
	my ($parentclass) = $code =~ /extends (\w+)/;

	my @props = ();
	foreach($code =~ m/((?:\@XmlElement|protected)[^;]+);/g) {
		my ($alias, $required, $nillable, $type, $name) = $_ =~ /^(?:\@XmlElement\((?:name = \"(\w+)\"|)((?:, |)required = true)?((?:, |)nillable = true)?\).*protected|protected) ([\w<>]+) (\w+)$/s;
		my $simpletype = is_java_simple_type($type);
		my %arr = ( 
			'alias' => $alias,
			'required' => (($simpletype || defined $required) or 0),
			'nillable' => ((!$simpletype && defined $nillable) or 0),
			'type' => $type,
			'name' => $name
			);
		push @props, \%arr;
	}
	
	@{$_[0]}{'parentclass'} = $parentclass;
	@{$_[0]}{'props'} = \@props;
};

# param in $type - name of java type
sub is_java_simple_type
{
	return $_[0] =~ /^(?:byte|char|short|int|long|float|double|boolean)$/;
};

# param in \%info - reference to map of informations about this class
# param in \@enums - reference to list of all enum names
sub get_class_code_kt 
{
	my %info = %{$_[0]};
	my @enums = @{$_[1]};
	
	my @imports = (
		"import com.tickaroo.tikxml.annotation.Xml"
	);
	my @props = ();
	foreach(@{@info{'props'}}) {
		my %prop = %$_;
		my $optional = !@prop{'required'} || @prop{'nillable'};

		my @ktype = define_kt_type(@prop{'type'}, @prop{'required'} && !@prop{'nillable'}, \@enums);
		push(@imports, @ktype[1]);
		push(@imports, "import com.tickaroo.tikxml.annotation.".(@ktype[0]?"Property":"")."Element");

		my @annotationProps = ();
		my $annotation = @ktype[0] ? "\@PropertyElement" : "\@Element";
		if(defined @prop{'alias'} && @prop{'alias'} ne @prop{'name'}) { push @annotationProps, "name=\"@prop{'alias'}\""; }
		if(@ktype[3] ne "") { push @annotationProps, "converter=@ktype[3]"; }
		my $prop_code = $annotation.(@annotationProps?'('.join(', ', @annotationProps).')':'')." val @prop{'name'}: @ktype[2]";
		push(@props, $prop_code);
	}
	
	my $ktcode = 
	"package @info{'package'}\n".
	"\n".
	join("\n", uniq(@imports))."\n".
	"\n".
	"\@Xml".(@info{'name'} eq @info{'alias'} ? "" : "(name=\"@info{'alias'}\")")."\n".
	"class @info{'name'}(".join(",\n".(" " x (7+length(@info{'name'}))), @props).")\n"; 
	
	#.(defined $parentclass ? " : $parentclass" : "");
	return $ktcode;
};

# convert Java-types to Kotlin-Types allowing also for custom import
# param in $type - name of java type
# param in $required - if type cannot be nillable
# param in \@enums - reference to list of enum names, as they require additional converters
# return @type : ($is_simple_type, $additional_import, $kt_type, $converter) 
sub define_kt_type
{
	my @enums = @{$_[2]};
	my $original = $_[0].($_[1] ? "" : "?");
	given($_[0]) {
		when('boolean') { return (1, "", "Boolean", ""); }
		when('Boolean') { return (1, "", "Boolean?", ""); }
		when('BigDecimal') {
			push @additionalConverters, $_;
			return (1, "import java.math.BigDecimal", $original, "BigDecimalConverter::class"); 
		} 
		when('int') { return (1, "", "Int", ""); }
		when('Integer') { return (1, "", "Int?", ""); }
		when('long') { return (1, "", "Long", ""); }
		when('String') { return (1, "", $original, ""); }
		when('XMLGregorianCalendar') { return (1, "import java.util.Date", "Date".($_[1] ? "" : "?"), ""); }
		when(/List<\w+>/) { return (0, "import java.util.List", $original, ""); }
		default {
			#is it enum?
			if (defined grep(/^$_$/, @enums)) {
				return (1, "", $original, "$_.Converter::class");
			}
			push @additionalConverters, $_;
			return (0, "", $original, "");
		}
	}
};

# param in/out \%info - reference to map where additional info about enum will be stored
sub extract_enum_info
{
	my $code = @{$_[0]}{'code'};

	my @values = ();
	foreach($code =~ m/(\@XmlEnumValue[^,;]+)(?:,|;)/g) {
		my ($alias, $name) = $_ =~ /^\@XmlEnumValue\(\"(\w+)\"\)\s+([\w]+)\(\"\w+\"\)$/s;
		my %arr = ( 
			'name' => $name,
			'alias' => $alias
			);
		push @values, \%arr;
	}
	
	@{$_[0]}{'values'} = \@values;
};

# param in \%info - reference to map of informations about this enum
sub get_enum_code_kt
{
	my %info = %{$_[0]};
	my @imports = (
		"import com.tickaroo.tikxml.TypeConverter"
		);
	my @props = ();
	my @write_conditions = ();
	my @read_conditions = ();
	foreach(@{@info{'values'}}) {
		my $name = %$_{'name'};
		my $alias = %$_{'alias'};
		push @props, $name;
		push @write_conditions, "$name -> \"$alias\"";
		push @read_conditions, "\"$alias\" -> $name";
	}
	push @read_conditions, "else -> null";
	my $ktcode = 
		"package @info{'package'}\n".
		"\n".
		join("\n", uniq(@imports))."\n".
		"\n".
		"enum class @info{'name'} {\n".
		"\t".join(",\n\t", @props).";\n".
		"\n".
		"	class Converter: TypeConverter<@info{'name'}> {\n".
		"		override fun write(value: @info{'name'}): String {\n".
		"			return when (value) {\n".
		"				".join("\n\t\t\t\t", @write_conditions)."\n".
		"			}\n".
		"		}\n".
		"\n".
		"		override fun read(value: String): @info{'name'}? {\n".
		"			return when (value) {\n".
		"				".join("\n\t\t\t\t", @read_conditions)."\n".
		"			}\n".
		"		}\n".
		"	}\n".
		"}\n";
	return $ktcode;
};

# create list of only unique values from given list argument
sub uniq
{ 
	my %seen = ( "" => 1);
	my @unique = ();
	foreach my $value (@_) {
	  if (! $seen{$value}) {
		push @unique, $value;
		$seen{$value} = 1;
	  }
	}
	return @unique;
};
